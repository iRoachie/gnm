// Code generated by Prisma (prisma@1.28.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  attendance: (where?: AttendanceWhereInput) => Promise<boolean>;
  contactSite: (where?: ContactSiteWhereInput) => Promise<boolean>;
  permission: (where?: PermissionWhereInput) => Promise<boolean>;
  person: (where?: PersonWhereInput) => Promise<boolean>;
  personStatus: (where?: PersonStatusWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
  userRole: (where?: UserRoleWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  attendances: (
    args?: {
      where?: AttendanceWhereInput;
      orderBy?: AttendanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Attendance>;
  attendancesConnection: (
    args?: {
      where?: AttendanceWhereInput;
      orderBy?: AttendanceOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => AttendanceConnectionPromise;
  contactSite: (where: ContactSiteWhereUniqueInput) => ContactSitePromise;
  contactSites: (
    args?: {
      where?: ContactSiteWhereInput;
      orderBy?: ContactSiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<ContactSite>;
  contactSitesConnection: (
    args?: {
      where?: ContactSiteWhereInput;
      orderBy?: ContactSiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ContactSiteConnectionPromise;
  permission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  permissions: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Permission>;
  permissionsConnection: (
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PermissionConnectionPromise;
  person: (where: PersonWhereUniqueInput) => PersonPromise;
  persons: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Person>;
  personsConnection: (
    args?: {
      where?: PersonWhereInput;
      orderBy?: PersonOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PersonConnectionPromise;
  personStatus: (where: PersonStatusWhereUniqueInput) => PersonStatusPromise;
  personStatuses: (
    args?: {
      where?: PersonStatusWhereInput;
      orderBy?: PersonStatusOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PersonStatus>;
  personStatusesConnection: (
    args?: {
      where?: PersonStatusWhereInput;
      orderBy?: PersonStatusOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PersonStatusConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  userRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  userRoles: (
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserRole>;
  userRolesConnection: (
    args?: {
      where?: UserRoleWhereInput;
      orderBy?: UserRoleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserRoleConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAttendance: (data: AttendanceCreateInput) => AttendancePromise;
  updateManyAttendances: (
    args: {
      data: AttendanceUpdateManyMutationInput;
      where?: AttendanceWhereInput;
    }
  ) => BatchPayloadPromise;
  deleteManyAttendances: (where?: AttendanceWhereInput) => BatchPayloadPromise;
  createContactSite: (data: ContactSiteCreateInput) => ContactSitePromise;
  updateContactSite: (
    args: { data: ContactSiteUpdateInput; where: ContactSiteWhereUniqueInput }
  ) => ContactSitePromise;
  updateManyContactSites: (
    args: {
      data: ContactSiteUpdateManyMutationInput;
      where?: ContactSiteWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertContactSite: (
    args: {
      where: ContactSiteWhereUniqueInput;
      create: ContactSiteCreateInput;
      update: ContactSiteUpdateInput;
    }
  ) => ContactSitePromise;
  deleteContactSite: (where: ContactSiteWhereUniqueInput) => ContactSitePromise;
  deleteManyContactSites: (
    where?: ContactSiteWhereInput
  ) => BatchPayloadPromise;
  createPermission: (data: PermissionCreateInput) => PermissionPromise;
  updatePermission: (
    args: { data: PermissionUpdateInput; where: PermissionWhereUniqueInput }
  ) => PermissionPromise;
  updateManyPermissions: (
    args: {
      data: PermissionUpdateManyMutationInput;
      where?: PermissionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPermission: (
    args: {
      where: PermissionWhereUniqueInput;
      create: PermissionCreateInput;
      update: PermissionUpdateInput;
    }
  ) => PermissionPromise;
  deletePermission: (where: PermissionWhereUniqueInput) => PermissionPromise;
  deleteManyPermissions: (where?: PermissionWhereInput) => BatchPayloadPromise;
  createPerson: (data: PersonCreateInput) => PersonPromise;
  updatePerson: (
    args: { data: PersonUpdateInput; where: PersonWhereUniqueInput }
  ) => PersonPromise;
  updateManyPersons: (
    args: { data: PersonUpdateManyMutationInput; where?: PersonWhereInput }
  ) => BatchPayloadPromise;
  upsertPerson: (
    args: {
      where: PersonWhereUniqueInput;
      create: PersonCreateInput;
      update: PersonUpdateInput;
    }
  ) => PersonPromise;
  deletePerson: (where: PersonWhereUniqueInput) => PersonPromise;
  deleteManyPersons: (where?: PersonWhereInput) => BatchPayloadPromise;
  createPersonStatus: (data: PersonStatusCreateInput) => PersonStatusPromise;
  updatePersonStatus: (
    args: { data: PersonStatusUpdateInput; where: PersonStatusWhereUniqueInput }
  ) => PersonStatusPromise;
  updateManyPersonStatuses: (
    args: {
      data: PersonStatusUpdateManyMutationInput;
      where?: PersonStatusWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPersonStatus: (
    args: {
      where: PersonStatusWhereUniqueInput;
      create: PersonStatusCreateInput;
      update: PersonStatusUpdateInput;
    }
  ) => PersonStatusPromise;
  deletePersonStatus: (
    where: PersonStatusWhereUniqueInput
  ) => PersonStatusPromise;
  deleteManyPersonStatuses: (
    where?: PersonStatusWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;
  createUserRole: (data: UserRoleCreateInput) => UserRolePromise;
  updateUserRole: (
    args: { data: UserRoleUpdateInput; where: UserRoleWhereUniqueInput }
  ) => UserRolePromise;
  updateManyUserRoles: (
    args: { data: UserRoleUpdateManyMutationInput; where?: UserRoleWhereInput }
  ) => BatchPayloadPromise;
  upsertUserRole: (
    args: {
      where: UserRoleWhereUniqueInput;
      create: UserRoleCreateInput;
      update: UserRoleUpdateInput;
    }
  ) => UserRolePromise;
  deleteUserRole: (where: UserRoleWhereUniqueInput) => UserRolePromise;
  deleteManyUserRoles: (where?: UserRoleWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  attendance: (
    where?: AttendanceSubscriptionWhereInput
  ) => AttendanceSubscriptionPayloadSubscription;
  contactSite: (
    where?: ContactSiteSubscriptionWhereInput
  ) => ContactSiteSubscriptionPayloadSubscription;
  permission: (
    where?: PermissionSubscriptionWhereInput
  ) => PermissionSubscriptionPayloadSubscription;
  person: (
    where?: PersonSubscriptionWhereInput
  ) => PersonSubscriptionPayloadSubscription;
  personStatus: (
    where?: PersonStatusSubscriptionWhereInput
  ) => PersonStatusSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
  userRole: (
    where?: UserRoleSubscriptionWhereInput
  ) => UserRoleSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Sex = "M" | "F";

export type Country = "Barbados" | "Dominica";

export type AttendanceOrderByInput =
  | "date_ASC"
  | "date_DESC"
  | "event_ASC"
  | "event_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PermissionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ContactSiteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "country_ASC"
  | "country_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PersonOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "telephone_ASC"
  | "telephone_DESC"
  | "address_ASC"
  | "address_DESC"
  | "sex_ASC"
  | "sex_DESC"
  | "religion_ASC"
  | "religion_DESC"
  | "age_ASC"
  | "age_DESC"
  | "notes_ASC"
  | "notes_DESC"
  | "websiteUser_ASC"
  | "websiteUser_DESC"
  | "invitation_ASC"
  | "invitation_DESC"
  | "letter_ASC"
  | "letter_DESC"
  | "handbill_ASC"
  | "handbill_DESC"
  | "guestTag_ASC"
  | "guestTag_DESC"
  | "transport_ASC"
  | "transport_DESC"
  | "openingNight_ASC"
  | "openingNight_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type PersonStatusOrderByInput =
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserRoleOrderByInput =
  | "title_ASC"
  | "title_DESC"
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface PermissionCreateManyInput {
  create?: PermissionCreateInput[] | PermissionCreateInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
}

export interface AttendanceWhereInput {
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  event?: String;
  event_not?: String;
  event_in?: String[] | String;
  event_not_in?: String[] | String;
  event_lt?: String;
  event_lte?: String;
  event_gt?: String;
  event_gte?: String;
  event_contains?: String;
  event_not_contains?: String;
  event_starts_with?: String;
  event_not_starts_with?: String;
  event_ends_with?: String;
  event_not_ends_with?: String;
  person?: PersonWhereInput;
  AND?: AttendanceWhereInput[] | AttendanceWhereInput;
  OR?: AttendanceWhereInput[] | AttendanceWhereInput;
  NOT?: AttendanceWhereInput[] | AttendanceWhereInput;
}

export interface PermissionUpdateManyDataInput {
  title?: String;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  role?: UserRoleUpdateOneRequiredInput;
  contactSites?: ContactSiteUpdateManyInput;
}

export interface PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput;
  data: PermissionUpdateManyDataInput;
}

export interface ContactSiteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  country?: Country;
  country_not?: Country;
  country_in?: Country[] | Country;
  country_not_in?: Country[] | Country;
  AND?: ContactSiteWhereInput[] | ContactSiteWhereInput;
  OR?: ContactSiteWhereInput[] | ContactSiteWhereInput;
  NOT?: ContactSiteWhereInput[] | ContactSiteWhereInput;
}

export interface PermissionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  OR?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  NOT?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
}

export interface UserRoleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserRoleWhereInput;
  AND?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
  OR?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
  NOT?: UserRoleSubscriptionWhereInput[] | UserRoleSubscriptionWhereInput;
}

export type UserRoleWhereUniqueInput = AtLeastOne<{
  title: String;
}>;

export interface PersonStatusSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonStatusWhereInput;
  AND?:
    | PersonStatusSubscriptionWhereInput[]
    | PersonStatusSubscriptionWhereInput;
  OR?:
    | PersonStatusSubscriptionWhereInput[]
    | PersonStatusSubscriptionWhereInput;
  NOT?:
    | PersonStatusSubscriptionWhereInput[]
    | PersonStatusSubscriptionWhereInput;
}

export interface PersonWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  telephone?: String;
  telephone_not?: String;
  telephone_in?: String[] | String;
  telephone_not_in?: String[] | String;
  telephone_lt?: String;
  telephone_lte?: String;
  telephone_gt?: String;
  telephone_gte?: String;
  telephone_contains?: String;
  telephone_not_contains?: String;
  telephone_starts_with?: String;
  telephone_not_starts_with?: String;
  telephone_ends_with?: String;
  telephone_not_ends_with?: String;
  status?: PersonStatusWhereInput;
  address?: String;
  address_not?: String;
  address_in?: String[] | String;
  address_not_in?: String[] | String;
  address_lt?: String;
  address_lte?: String;
  address_gt?: String;
  address_gte?: String;
  address_contains?: String;
  address_not_contains?: String;
  address_starts_with?: String;
  address_not_starts_with?: String;
  address_ends_with?: String;
  address_not_ends_with?: String;
  sex?: Sex;
  sex_not?: Sex;
  sex_in?: Sex[] | Sex;
  sex_not_in?: Sex[] | Sex;
  religion?: String;
  religion_not?: String;
  religion_in?: String[] | String;
  religion_not_in?: String[] | String;
  religion_lt?: String;
  religion_lte?: String;
  religion_gt?: String;
  religion_gte?: String;
  religion_contains?: String;
  religion_not_contains?: String;
  religion_starts_with?: String;
  religion_not_starts_with?: String;
  religion_ends_with?: String;
  religion_not_ends_with?: String;
  age?: Int;
  age_not?: Int;
  age_in?: Int[] | Int;
  age_not_in?: Int[] | Int;
  age_lt?: Int;
  age_lte?: Int;
  age_gt?: Int;
  age_gte?: Int;
  assignee?: UserWhereInput;
  contactSite?: ContactSiteWhereInput;
  notes?: String;
  notes_not?: String;
  notes_in?: String[] | String;
  notes_not_in?: String[] | String;
  notes_lt?: String;
  notes_lte?: String;
  notes_gt?: String;
  notes_gte?: String;
  notes_contains?: String;
  notes_not_contains?: String;
  notes_starts_with?: String;
  notes_not_starts_with?: String;
  notes_ends_with?: String;
  notes_not_ends_with?: String;
  websiteUser?: Boolean;
  websiteUser_not?: Boolean;
  invitation?: Boolean;
  invitation_not?: Boolean;
  letter?: Boolean;
  letter_not?: Boolean;
  handbill?: Boolean;
  handbill_not?: Boolean;
  guestTag?: Boolean;
  guestTag_not?: Boolean;
  transport?: Boolean;
  transport_not?: Boolean;
  openingNight?: Boolean;
  openingNight_not?: Boolean;
  AND?: PersonWhereInput[] | PersonWhereInput;
  OR?: PersonWhereInput[] | PersonWhereInput;
  NOT?: PersonWhereInput[] | PersonWhereInput;
}

export interface PermissionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PermissionWhereInput;
  AND?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  OR?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
  NOT?: PermissionSubscriptionWhereInput[] | PermissionSubscriptionWhereInput;
}

export interface PermissionUpsertWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput;
  update: PermissionUpdateDataInput;
  create: PermissionCreateInput;
}

export interface ContactSiteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ContactSiteWhereInput;
  AND?: ContactSiteSubscriptionWhereInput[] | ContactSiteSubscriptionWhereInput;
  OR?: ContactSiteSubscriptionWhereInput[] | ContactSiteSubscriptionWhereInput;
  NOT?: ContactSiteSubscriptionWhereInput[] | ContactSiteSubscriptionWhereInput;
}

export interface PermissionUpdateDataInput {
  title?: String;
}

export interface AttendanceSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: AttendanceWhereInput;
  AND?: AttendanceSubscriptionWhereInput[] | AttendanceSubscriptionWhereInput;
  OR?: AttendanceSubscriptionWhereInput[] | AttendanceSubscriptionWhereInput;
  NOT?: AttendanceSubscriptionWhereInput[] | AttendanceSubscriptionWhereInput;
}

export interface PermissionUpdateWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput;
  data: PermissionUpdateDataInput;
}

export interface UserRoleUpdateInput {
  title?: String;
  permissions?: PermissionUpdateManyInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  role?: UserRoleUpdateOneRequiredInput;
  contactSites?: ContactSiteUpdateManyInput;
}

export interface PersonStatusUpdateManyMutationInput {
  title?: String;
  description?: String;
}

export interface AttendanceCreateInput {
  date: DateTimeInput;
  event?: String;
  person: PersonCreateOneInput;
}

export interface PersonUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  telephone?: String;
  address?: String;
  sex?: Sex;
  religion?: String;
  age?: Int;
  notes?: String;
  websiteUser?: Boolean;
  invitation?: Boolean;
  letter?: Boolean;
  handbill?: Boolean;
  guestTag?: Boolean;
  transport?: Boolean;
  openingNight?: Boolean;
}

export interface PersonCreateOneInput {
  create?: PersonCreateInput;
  connect?: PersonWhereUniqueInput;
}

export interface ContactSiteUpsertNestedInput {
  update: ContactSiteUpdateDataInput;
  create: ContactSiteCreateInput;
}

export interface PersonCreateInput {
  name: String;
  email?: String;
  password?: String;
  telephone?: String;
  status: PersonStatusCreateOneInput;
  address?: String;
  sex: Sex;
  religion?: String;
  age?: Int;
  assignee?: UserCreateOneInput;
  contactSite: ContactSiteCreateOneInput;
  notes?: String;
  websiteUser?: Boolean;
  invitation?: Boolean;
  letter?: Boolean;
  handbill?: Boolean;
  guestTag?: Boolean;
  transport?: Boolean;
  openingNight?: Boolean;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface PersonStatusCreateOneInput {
  create?: PersonStatusCreateInput;
  connect?: PersonStatusWhereUniqueInput;
}

export interface ContactSiteUpdateManyDataInput {
  name?: String;
  country?: Country;
}

export interface PersonStatusCreateInput {
  title: String;
  description?: String;
}

export interface ContactSiteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  country?: Country;
  country_not?: Country;
  country_in?: Country[] | Country;
  country_not_in?: Country[] | Country;
  AND?: ContactSiteScalarWhereInput[] | ContactSiteScalarWhereInput;
  OR?: ContactSiteScalarWhereInput[] | ContactSiteScalarWhereInput;
  NOT?: ContactSiteScalarWhereInput[] | ContactSiteScalarWhereInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export type PersonStatusWhereUniqueInput = AtLeastOne<{
  title: String;
}>;

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  role: UserRoleCreateOneInput;
  contactSites?: ContactSiteCreateManyInput;
}

export interface ContactSiteUpdateDataInput {
  name?: String;
  country?: Country;
}

export interface UserRoleCreateOneInput {
  create?: UserRoleCreateInput;
  connect?: UserRoleWhereUniqueInput;
}

export interface ContactSiteUpdateManyInput {
  create?: ContactSiteCreateInput[] | ContactSiteCreateInput;
  update?:
    | ContactSiteUpdateWithWhereUniqueNestedInput[]
    | ContactSiteUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ContactSiteUpsertWithWhereUniqueNestedInput[]
    | ContactSiteUpsertWithWhereUniqueNestedInput;
  delete?: ContactSiteWhereUniqueInput[] | ContactSiteWhereUniqueInput;
  connect?: ContactSiteWhereUniqueInput[] | ContactSiteWhereUniqueInput;
  set?: ContactSiteWhereUniqueInput[] | ContactSiteWhereUniqueInput;
  disconnect?: ContactSiteWhereUniqueInput[] | ContactSiteWhereUniqueInput;
  deleteMany?: ContactSiteScalarWhereInput[] | ContactSiteScalarWhereInput;
  updateMany?:
    | ContactSiteUpdateManyWithWhereNestedInput[]
    | ContactSiteUpdateManyWithWhereNestedInput;
}

export interface UserRoleCreateInput {
  title: String;
  permissions?: PermissionCreateManyInput;
}

export interface UserRoleUpsertNestedInput {
  update: UserRoleUpdateDataInput;
  create: UserRoleCreateInput;
}

export interface PermissionUpdateManyInput {
  create?: PermissionCreateInput[] | PermissionCreateInput;
  update?:
    | PermissionUpdateWithWhereUniqueNestedInput[]
    | PermissionUpdateWithWhereUniqueNestedInput;
  upsert?:
    | PermissionUpsertWithWhereUniqueNestedInput[]
    | PermissionUpsertWithWhereUniqueNestedInput;
  delete?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  connect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  set?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  disconnect?: PermissionWhereUniqueInput[] | PermissionWhereUniqueInput;
  deleteMany?: PermissionScalarWhereInput[] | PermissionScalarWhereInput;
  updateMany?:
    | PermissionUpdateManyWithWhereNestedInput[]
    | PermissionUpdateManyWithWhereNestedInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface PermissionCreateInput {
  title: String;
}

export interface UserRoleWhereInput {
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  permissions_every?: PermissionWhereInput;
  permissions_some?: PermissionWhereInput;
  permissions_none?: PermissionWhereInput;
  AND?: UserRoleWhereInput[] | UserRoleWhereInput;
  OR?: UserRoleWhereInput[] | UserRoleWhereInput;
  NOT?: UserRoleWhereInput[] | UserRoleWhereInput;
}

export interface ContactSiteCreateManyInput {
  create?: ContactSiteCreateInput[] | ContactSiteCreateInput;
  connect?: ContactSiteWhereUniqueInput[] | ContactSiteWhereUniqueInput;
}

export interface UserRoleUpdateManyMutationInput {
  title?: String;
}

export interface ContactSiteCreateInput {
  name: String;
  country: Country;
}

export type ContactSiteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ContactSiteCreateOneInput {
  create?: ContactSiteCreateInput;
  connect?: ContactSiteWhereUniqueInput;
}

export type PermissionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface AttendanceUpdateManyMutationInput {
  date?: DateTimeInput;
  event?: String;
}

export type PersonWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserRoleUpdateDataInput {
  title?: String;
  permissions?: PermissionUpdateManyInput;
}

export interface ContactSiteUpsertWithWhereUniqueNestedInput {
  where: ContactSiteWhereUniqueInput;
  update: ContactSiteUpdateDataInput;
  create: ContactSiteCreateInput;
}

export interface UserRoleUpdateOneRequiredInput {
  create?: UserRoleCreateInput;
  update?: UserRoleUpdateDataInput;
  upsert?: UserRoleUpsertNestedInput;
  connect?: UserRoleWhereUniqueInput;
}

export interface ContactSiteUpdateWithWhereUniqueNestedInput {
  where: ContactSiteWhereUniqueInput;
  data: ContactSiteUpdateDataInput;
}

export interface ContactSiteUpdateInput {
  name?: String;
  country?: Country;
}

export interface PermissionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  AND?: PermissionWhereInput[] | PermissionWhereInput;
  OR?: PermissionWhereInput[] | PermissionWhereInput;
  NOT?: PermissionWhereInput[] | PermissionWhereInput;
}

export interface ContactSiteUpdateManyMutationInput {
  name?: String;
  country?: Country;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  role?: UserRoleWhereInput;
  contactSites_every?: ContactSiteWhereInput;
  contactSites_some?: ContactSiteWhereInput;
  contactSites_none?: ContactSiteWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PermissionUpdateInput {
  title?: String;
}

export interface PersonStatusUpdateInput {
  title?: String;
  description?: String;
}

export interface PermissionUpdateManyMutationInput {
  title?: String;
}

export interface ContactSiteUpdateManyWithWhereNestedInput {
  where: ContactSiteScalarWhereInput;
  data: ContactSiteUpdateManyDataInput;
}

export interface PersonUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  telephone?: String;
  status?: PersonStatusUpdateOneRequiredInput;
  address?: String;
  sex?: Sex;
  religion?: String;
  age?: Int;
  assignee?: UserUpdateOneInput;
  contactSite?: ContactSiteUpdateOneRequiredInput;
  notes?: String;
  websiteUser?: Boolean;
  invitation?: Boolean;
  letter?: Boolean;
  handbill?: Boolean;
  guestTag?: Boolean;
  transport?: Boolean;
  openingNight?: Boolean;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PersonStatusUpsertNestedInput {
  update: PersonStatusUpdateDataInput;
  create: PersonStatusCreateInput;
}

export interface PersonStatusUpdateDataInput {
  title?: String;
  description?: String;
}

export interface PersonStatusUpdateOneRequiredInput {
  create?: PersonStatusCreateInput;
  update?: PersonStatusUpdateDataInput;
  upsert?: PersonStatusUpsertNestedInput;
  connect?: PersonStatusWhereUniqueInput;
}

export interface PersonSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PersonWhereInput;
  AND?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  OR?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
  NOT?: PersonSubscriptionWhereInput[] | PersonSubscriptionWhereInput;
}

export interface PersonStatusWhereInput {
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  AND?: PersonStatusWhereInput[] | PersonStatusWhereInput;
  OR?: PersonStatusWhereInput[] | PersonStatusWhereInput;
  NOT?: PersonStatusWhereInput[] | PersonStatusWhereInput;
}

export interface ContactSiteUpdateOneRequiredInput {
  create?: ContactSiteCreateInput;
  update?: ContactSiteUpdateDataInput;
  upsert?: ContactSiteUpsertNestedInput;
  connect?: ContactSiteWhereUniqueInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AttendanceEdge {
  node: Attendance;
  cursor: String;
}

export interface AttendanceEdgePromise
  extends Promise<AttendanceEdge>,
    Fragmentable {
  node: <T = AttendancePromise>() => T;
  cursor: () => Promise<String>;
}

export interface AttendanceEdgeSubscription
  extends Promise<AsyncIterator<AttendanceEdge>>,
    Fragmentable {
  node: <T = AttendanceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRolePreviousValues {
  title: String;
}

export interface UserRolePreviousValuesPromise
  extends Promise<UserRolePreviousValues>,
    Fragmentable {
  title: () => Promise<String>;
}

export interface UserRolePreviousValuesSubscription
  extends Promise<AsyncIterator<UserRolePreviousValues>>,
    Fragmentable {
  title: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAttendance {
  count: Int;
}

export interface AggregateAttendancePromise
  extends Promise<AggregateAttendance>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAttendanceSubscription
  extends Promise<AsyncIterator<AggregateAttendance>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Person {
  id: ID_Output;
  name: String;
  email?: String;
  password?: String;
  telephone?: String;
  address?: String;
  sex: Sex;
  religion?: String;
  age?: Int;
  notes?: String;
  websiteUser?: Boolean;
  invitation?: Boolean;
  letter?: Boolean;
  handbill?: Boolean;
  guestTag?: Boolean;
  transport?: Boolean;
  openingNight?: Boolean;
}

export interface PersonPromise extends Promise<Person>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  telephone: () => Promise<String>;
  status: <T = PersonStatusPromise>() => T;
  address: () => Promise<String>;
  sex: () => Promise<Sex>;
  religion: () => Promise<String>;
  age: () => Promise<Int>;
  assignee: <T = UserPromise>() => T;
  contactSite: <T = ContactSitePromise>() => T;
  notes: () => Promise<String>;
  websiteUser: () => Promise<Boolean>;
  invitation: () => Promise<Boolean>;
  letter: () => Promise<Boolean>;
  handbill: () => Promise<Boolean>;
  guestTag: () => Promise<Boolean>;
  transport: () => Promise<Boolean>;
  openingNight: () => Promise<Boolean>;
}

export interface PersonSubscription
  extends Promise<AsyncIterator<Person>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  status: <T = PersonStatusSubscription>() => T;
  address: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<Sex>>;
  religion: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  assignee: <T = UserSubscription>() => T;
  contactSite: <T = ContactSiteSubscription>() => T;
  notes: () => Promise<AsyncIterator<String>>;
  websiteUser: () => Promise<AsyncIterator<Boolean>>;
  invitation: () => Promise<AsyncIterator<Boolean>>;
  letter: () => Promise<AsyncIterator<Boolean>>;
  handbill: () => Promise<AsyncIterator<Boolean>>;
  guestTag: () => Promise<AsyncIterator<Boolean>>;
  transport: () => Promise<AsyncIterator<Boolean>>;
  openingNight: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserRole {
  count: Int;
}

export interface AggregateUserRolePromise
  extends Promise<AggregateUserRole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserRoleSubscription
  extends Promise<AsyncIterator<AggregateUserRole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserRoleConnection {
  pageInfo: PageInfo;
  edges: UserRoleEdge[];
}

export interface UserRoleConnectionPromise
  extends Promise<UserRoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserRoleEdge>>() => T;
  aggregate: <T = AggregateUserRolePromise>() => T;
}

export interface UserRoleConnectionSubscription
  extends Promise<AsyncIterator<UserRoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserRoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserRoleSubscription>() => T;
}

export interface AttendanceConnection {
  pageInfo: PageInfo;
  edges: AttendanceEdge[];
}

export interface AttendanceConnectionPromise
  extends Promise<AttendanceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AttendanceEdge>>() => T;
  aggregate: <T = AggregateAttendancePromise>() => T;
}

export interface AttendanceConnectionSubscription
  extends Promise<AsyncIterator<AttendanceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AttendanceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAttendanceSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ContactSite {
  id: ID_Output;
  name: String;
  country: Country;
}

export interface ContactSitePromise extends Promise<ContactSite>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  country: () => Promise<Country>;
}

export interface ContactSiteSubscription
  extends Promise<AsyncIterator<ContactSite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<Country>>;
}

export interface UserRoleSubscriptionPayload {
  mutation: MutationType;
  node: UserRole;
  updatedFields: String[];
  previousValues: UserRolePreviousValues;
}

export interface UserRoleSubscriptionPayloadPromise
  extends Promise<UserRoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserRolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserRolePreviousValuesPromise>() => T;
}

export interface UserRoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserRoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserRoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserRolePreviousValuesSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PersonStatusEdge {
  node: PersonStatus;
  cursor: String;
}

export interface PersonStatusEdgePromise
  extends Promise<PersonStatusEdge>,
    Fragmentable {
  node: <T = PersonStatusPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonStatusEdgeSubscription
  extends Promise<AsyncIterator<PersonStatusEdge>>,
    Fragmentable {
  node: <T = PersonStatusSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AttendanceSubscriptionPayload {
  mutation: MutationType;
  node: Attendance;
  updatedFields: String[];
  previousValues: AttendancePreviousValues;
}

export interface AttendanceSubscriptionPayloadPromise
  extends Promise<AttendanceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AttendancePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AttendancePreviousValuesPromise>() => T;
}

export interface AttendanceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AttendanceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AttendanceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AttendancePreviousValuesSubscription>() => T;
}

export interface AggregatePerson {
  count: Int;
}

export interface AggregatePersonPromise
  extends Promise<AggregatePerson>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonSubscription
  extends Promise<AsyncIterator<AggregatePerson>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AttendancePreviousValues {
  date: DateTimeOutput;
  event?: String;
}

export interface AttendancePreviousValuesPromise
  extends Promise<AttendancePreviousValues>,
    Fragmentable {
  date: () => Promise<DateTimeOutput>;
  event: () => Promise<String>;
}

export interface AttendancePreviousValuesSubscription
  extends Promise<AsyncIterator<AttendancePreviousValues>>,
    Fragmentable {
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: () => Promise<AsyncIterator<String>>;
}

export interface PersonConnection {
  pageInfo: PageInfo;
  edges: PersonEdge[];
}

export interface PersonConnectionPromise
  extends Promise<PersonConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonEdge>>() => T;
  aggregate: <T = AggregatePersonPromise>() => T;
}

export interface PersonConnectionSubscription
  extends Promise<AsyncIterator<PersonConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonSubscription>() => T;
}

export interface Permission {
  id: ID_Output;
  title: String;
}

export interface PermissionPromise extends Promise<Permission>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface PermissionSubscription
  extends Promise<AsyncIterator<Permission>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePermission {
  count: Int;
}

export interface AggregatePermissionPromise
  extends Promise<AggregatePermission>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePermissionSubscription
  extends Promise<AsyncIterator<AggregatePermission>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactSiteSubscriptionPayload {
  mutation: MutationType;
  node: ContactSite;
  updatedFields: String[];
  previousValues: ContactSitePreviousValues;
}

export interface ContactSiteSubscriptionPayloadPromise
  extends Promise<ContactSiteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ContactSitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ContactSitePreviousValuesPromise>() => T;
}

export interface ContactSiteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ContactSiteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ContactSiteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ContactSitePreviousValuesSubscription>() => T;
}

export interface PermissionConnection {
  pageInfo: PageInfo;
  edges: PermissionEdge[];
}

export interface PermissionConnectionPromise
  extends Promise<PermissionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PermissionEdge>>() => T;
  aggregate: <T = AggregatePermissionPromise>() => T;
}

export interface PermissionConnectionSubscription
  extends Promise<AsyncIterator<PermissionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PermissionEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePermissionSubscription>() => T;
}

export interface ContactSitePreviousValues {
  id: ID_Output;
  name: String;
  country: Country;
}

export interface ContactSitePreviousValuesPromise
  extends Promise<ContactSitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  country: () => Promise<Country>;
}

export interface ContactSitePreviousValuesSubscription
  extends Promise<AsyncIterator<ContactSitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  country: () => Promise<AsyncIterator<Country>>;
}

export interface ContactSiteEdge {
  node: ContactSite;
  cursor: String;
}

export interface ContactSiteEdgePromise
  extends Promise<ContactSiteEdge>,
    Fragmentable {
  node: <T = ContactSitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ContactSiteEdgeSubscription
  extends Promise<AsyncIterator<ContactSiteEdge>>,
    Fragmentable {
  node: <T = ContactSiteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserRole {
  title: String;
}

export interface UserRolePromise extends Promise<UserRole>, Fragmentable {
  title: () => Promise<String>;
  permissions: <T = FragmentableArray<Permission>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserRoleSubscription
  extends Promise<AsyncIterator<UserRole>>,
    Fragmentable {
  title: () => Promise<AsyncIterator<String>>;
  permissions: <T = Promise<AsyncIterator<PermissionSubscription>>>(
    args?: {
      where?: PermissionWhereInput;
      orderBy?: PermissionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserRoleEdge {
  node: UserRole;
  cursor: String;
}

export interface UserRoleEdgePromise
  extends Promise<UserRoleEdge>,
    Fragmentable {
  node: <T = UserRolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserRoleEdgeSubscription
  extends Promise<AsyncIterator<UserRoleEdge>>,
    Fragmentable {
  node: <T = UserRoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PermissionSubscriptionPayload {
  mutation: MutationType;
  node: Permission;
  updatedFields: String[];
  previousValues: PermissionPreviousValues;
}

export interface PermissionSubscriptionPayloadPromise
  extends Promise<PermissionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PermissionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PermissionPreviousValuesPromise>() => T;
}

export interface PermissionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PermissionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PermissionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PermissionPreviousValuesSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface PermissionPreviousValues {
  id: ID_Output;
  title: String;
}

export interface PermissionPreviousValuesPromise
  extends Promise<PermissionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
}

export interface PermissionPreviousValuesSubscription
  extends Promise<AsyncIterator<PermissionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
}

export interface PersonStatusConnection {
  pageInfo: PageInfo;
  edges: PersonStatusEdge[];
}

export interface PersonStatusConnectionPromise
  extends Promise<PersonStatusConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PersonStatusEdge>>() => T;
  aggregate: <T = AggregatePersonStatusPromise>() => T;
}

export interface PersonStatusConnectionSubscription
  extends Promise<AsyncIterator<PersonStatusConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PersonStatusEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePersonStatusSubscription>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  role: <T = UserRolePromise>() => T;
  contactSites: <T = FragmentableArray<ContactSite>>(
    args?: {
      where?: ContactSiteWhereInput;
      orderBy?: ContactSiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: <T = UserRoleSubscription>() => T;
  contactSites: <T = Promise<AsyncIterator<ContactSiteSubscription>>>(
    args?: {
      where?: ContactSiteWhereInput;
      orderBy?: ContactSiteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Attendance {
  date: DateTimeOutput;
  event?: String;
}

export interface AttendancePromise extends Promise<Attendance>, Fragmentable {
  date: () => Promise<DateTimeOutput>;
  event: () => Promise<String>;
  person: <T = PersonPromise>() => T;
}

export interface AttendanceSubscription
  extends Promise<AsyncIterator<Attendance>>,
    Fragmentable {
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: () => Promise<AsyncIterator<String>>;
  person: <T = PersonSubscription>() => T;
}

export interface PersonSubscriptionPayload {
  mutation: MutationType;
  node: Person;
  updatedFields: String[];
  previousValues: PersonPreviousValues;
}

export interface PersonSubscriptionPayloadPromise
  extends Promise<PersonSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonPreviousValuesPromise>() => T;
}

export interface PersonSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonPreviousValuesSubscription>() => T;
}

export interface AggregateContactSite {
  count: Int;
}

export interface AggregateContactSitePromise
  extends Promise<AggregateContactSite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateContactSiteSubscription
  extends Promise<AsyncIterator<AggregateContactSite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PersonStatusPreviousValues {
  title: String;
  description?: String;
}

export interface PersonStatusPreviousValuesPromise
  extends Promise<PersonStatusPreviousValues>,
    Fragmentable {
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface PersonStatusPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonStatusPreviousValues>>,
    Fragmentable {
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PersonStatusSubscriptionPayload {
  mutation: MutationType;
  node: PersonStatus;
  updatedFields: String[];
  previousValues: PersonStatusPreviousValues;
}

export interface PersonStatusSubscriptionPayloadPromise
  extends Promise<PersonStatusSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PersonStatusPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PersonStatusPreviousValuesPromise>() => T;
}

export interface PersonStatusSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PersonStatusSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PersonStatusSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PersonStatusPreviousValuesSubscription>() => T;
}

export interface PersonStatus {
  title: String;
  description?: String;
}

export interface PersonStatusPromise
  extends Promise<PersonStatus>,
    Fragmentable {
  title: () => Promise<String>;
  description: () => Promise<String>;
}

export interface PersonStatusSubscription
  extends Promise<AsyncIterator<PersonStatus>>,
    Fragmentable {
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface PersonPreviousValues {
  id: ID_Output;
  name: String;
  email?: String;
  password?: String;
  telephone?: String;
  address?: String;
  sex: Sex;
  religion?: String;
  age?: Int;
  notes?: String;
  websiteUser?: Boolean;
  invitation?: Boolean;
  letter?: Boolean;
  handbill?: Boolean;
  guestTag?: Boolean;
  transport?: Boolean;
  openingNight?: Boolean;
}

export interface PersonPreviousValuesPromise
  extends Promise<PersonPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  telephone: () => Promise<String>;
  address: () => Promise<String>;
  sex: () => Promise<Sex>;
  religion: () => Promise<String>;
  age: () => Promise<Int>;
  notes: () => Promise<String>;
  websiteUser: () => Promise<Boolean>;
  invitation: () => Promise<Boolean>;
  letter: () => Promise<Boolean>;
  handbill: () => Promise<Boolean>;
  guestTag: () => Promise<Boolean>;
  transport: () => Promise<Boolean>;
  openingNight: () => Promise<Boolean>;
}

export interface PersonPreviousValuesSubscription
  extends Promise<AsyncIterator<PersonPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  telephone: () => Promise<AsyncIterator<String>>;
  address: () => Promise<AsyncIterator<String>>;
  sex: () => Promise<AsyncIterator<Sex>>;
  religion: () => Promise<AsyncIterator<String>>;
  age: () => Promise<AsyncIterator<Int>>;
  notes: () => Promise<AsyncIterator<String>>;
  websiteUser: () => Promise<AsyncIterator<Boolean>>;
  invitation: () => Promise<AsyncIterator<Boolean>>;
  letter: () => Promise<AsyncIterator<Boolean>>;
  handbill: () => Promise<AsyncIterator<Boolean>>;
  guestTag: () => Promise<AsyncIterator<Boolean>>;
  transport: () => Promise<AsyncIterator<Boolean>>;
  openingNight: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregatePersonStatus {
  count: Int;
}

export interface AggregatePersonStatusPromise
  extends Promise<AggregatePersonStatus>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePersonStatusSubscription
  extends Promise<AsyncIterator<AggregatePersonStatus>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ContactSiteConnection {
  pageInfo: PageInfo;
  edges: ContactSiteEdge[];
}

export interface ContactSiteConnectionPromise
  extends Promise<ContactSiteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ContactSiteEdge>>() => T;
  aggregate: <T = AggregateContactSitePromise>() => T;
}

export interface ContactSiteConnectionSubscription
  extends Promise<AsyncIterator<ContactSiteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ContactSiteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateContactSiteSubscription>() => T;
}

export interface PermissionEdge {
  node: Permission;
  cursor: String;
}

export interface PermissionEdgePromise
  extends Promise<PermissionEdge>,
    Fragmentable {
  node: <T = PermissionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PermissionEdgeSubscription
  extends Promise<AsyncIterator<PermissionEdge>>,
    Fragmentable {
  node: <T = PermissionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PersonEdge {
  node: Person;
  cursor: String;
}

export interface PersonEdgePromise extends Promise<PersonEdge>, Fragmentable {
  node: <T = PersonPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PersonEdgeSubscription
  extends Promise<AsyncIterator<PersonEdge>>,
    Fragmentable {
  node: <T = PersonSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Permission",
    embedded: false
  },
  {
    name: "PersonStatus",
    embedded: false
  },
  {
    name: "Sex",
    embedded: false
  },
  {
    name: "Country",
    embedded: false
  },
  {
    name: "ContactSite",
    embedded: false
  },
  {
    name: "Person",
    embedded: false
  },
  {
    name: "Attendance",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
