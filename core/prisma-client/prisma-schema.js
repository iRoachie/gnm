module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.28.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateAttendance {
  count: Int!
}

type AggregateContactSite {
  count: Int!
}

type AggregateNote {
  count: Int!
}

type AggregatePermission {
  count: Int!
}

type AggregatePerson {
  count: Int!
}

type AggregatePersonStatus {
  count: Int!
}

type AggregateTeam {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateUserRole {
  count: Int!
}

type Attendance {
  date: DateTime!
  event: String
  person: Person!
}

type AttendanceConnection {
  pageInfo: PageInfo!
  edges: [AttendanceEdge]!
  aggregate: AggregateAttendance!
}

input AttendanceCreateInput {
  date: DateTime!
  event: String
  person: PersonCreateOneInput!
}

type AttendanceEdge {
  node: Attendance!
  cursor: String!
}

enum AttendanceOrderByInput {
  date_ASC
  date_DESC
  event_ASC
  event_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AttendancePreviousValues {
  date: DateTime!
  event: String
}

type AttendanceSubscriptionPayload {
  mutation: MutationType!
  node: Attendance
  updatedFields: [String!]
  previousValues: AttendancePreviousValues
}

input AttendanceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AttendanceWhereInput
  AND: [AttendanceSubscriptionWhereInput!]
  OR: [AttendanceSubscriptionWhereInput!]
  NOT: [AttendanceSubscriptionWhereInput!]
}

input AttendanceUpdateManyMutationInput {
  date: DateTime
  event: String
}

input AttendanceWhereInput {
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  event: String
  event_not: String
  event_in: [String!]
  event_not_in: [String!]
  event_lt: String
  event_lte: String
  event_gt: String
  event_gte: String
  event_contains: String
  event_not_contains: String
  event_starts_with: String
  event_not_starts_with: String
  event_ends_with: String
  event_not_ends_with: String
  person: PersonWhereInput
  AND: [AttendanceWhereInput!]
  OR: [AttendanceWhereInput!]
  NOT: [AttendanceWhereInput!]
}

type BatchPayload {
  count: Long!
}

type ContactSite {
  id: ID!
  name: String!
  country: Country!
}

type ContactSiteConnection {
  pageInfo: PageInfo!
  edges: [ContactSiteEdge]!
  aggregate: AggregateContactSite!
}

input ContactSiteCreateInput {
  name: String!
  country: Country!
}

input ContactSiteCreateManyInput {
  create: [ContactSiteCreateInput!]
  connect: [ContactSiteWhereUniqueInput!]
}

input ContactSiteCreateOneInput {
  create: ContactSiteCreateInput
  connect: ContactSiteWhereUniqueInput
}

type ContactSiteEdge {
  node: ContactSite!
  cursor: String!
}

enum ContactSiteOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  country_ASC
  country_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ContactSitePreviousValues {
  id: ID!
  name: String!
  country: Country!
}

input ContactSiteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: Country
  country_not: Country
  country_in: [Country!]
  country_not_in: [Country!]
  AND: [ContactSiteScalarWhereInput!]
  OR: [ContactSiteScalarWhereInput!]
  NOT: [ContactSiteScalarWhereInput!]
}

type ContactSiteSubscriptionPayload {
  mutation: MutationType!
  node: ContactSite
  updatedFields: [String!]
  previousValues: ContactSitePreviousValues
}

input ContactSiteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ContactSiteWhereInput
  AND: [ContactSiteSubscriptionWhereInput!]
  OR: [ContactSiteSubscriptionWhereInput!]
  NOT: [ContactSiteSubscriptionWhereInput!]
}

input ContactSiteUpdateDataInput {
  name: String
  country: Country
}

input ContactSiteUpdateInput {
  name: String
  country: Country
}

input ContactSiteUpdateManyDataInput {
  name: String
  country: Country
}

input ContactSiteUpdateManyInput {
  create: [ContactSiteCreateInput!]
  update: [ContactSiteUpdateWithWhereUniqueNestedInput!]
  upsert: [ContactSiteUpsertWithWhereUniqueNestedInput!]
  delete: [ContactSiteWhereUniqueInput!]
  connect: [ContactSiteWhereUniqueInput!]
  set: [ContactSiteWhereUniqueInput!]
  disconnect: [ContactSiteWhereUniqueInput!]
  deleteMany: [ContactSiteScalarWhereInput!]
  updateMany: [ContactSiteUpdateManyWithWhereNestedInput!]
}

input ContactSiteUpdateManyMutationInput {
  name: String
  country: Country
}

input ContactSiteUpdateManyWithWhereNestedInput {
  where: ContactSiteScalarWhereInput!
  data: ContactSiteUpdateManyDataInput!
}

input ContactSiteUpdateOneRequiredInput {
  create: ContactSiteCreateInput
  update: ContactSiteUpdateDataInput
  upsert: ContactSiteUpsertNestedInput
  connect: ContactSiteWhereUniqueInput
}

input ContactSiteUpdateWithWhereUniqueNestedInput {
  where: ContactSiteWhereUniqueInput!
  data: ContactSiteUpdateDataInput!
}

input ContactSiteUpsertNestedInput {
  update: ContactSiteUpdateDataInput!
  create: ContactSiteCreateInput!
}

input ContactSiteUpsertWithWhereUniqueNestedInput {
  where: ContactSiteWhereUniqueInput!
  update: ContactSiteUpdateDataInput!
  create: ContactSiteCreateInput!
}

input ContactSiteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: Country
  country_not: Country
  country_in: [Country!]
  country_not_in: [Country!]
  AND: [ContactSiteWhereInput!]
  OR: [ContactSiteWhereInput!]
  NOT: [ContactSiteWhereInput!]
}

input ContactSiteWhereUniqueInput {
  id: ID
}

enum Country {
  Barbados
  Dominica
}

scalar DateTime

scalar Long

enum MaritalStatus {
  Single
  Married
  Divorced
  Widowed
}

type Mutation {
  createAttendance(data: AttendanceCreateInput!): Attendance!
  updateManyAttendances(data: AttendanceUpdateManyMutationInput!, where: AttendanceWhereInput): BatchPayload!
  deleteManyAttendances(where: AttendanceWhereInput): BatchPayload!
  createContactSite(data: ContactSiteCreateInput!): ContactSite!
  updateContactSite(data: ContactSiteUpdateInput!, where: ContactSiteWhereUniqueInput!): ContactSite
  updateManyContactSites(data: ContactSiteUpdateManyMutationInput!, where: ContactSiteWhereInput): BatchPayload!
  upsertContactSite(where: ContactSiteWhereUniqueInput!, create: ContactSiteCreateInput!, update: ContactSiteUpdateInput!): ContactSite!
  deleteContactSite(where: ContactSiteWhereUniqueInput!): ContactSite
  deleteManyContactSites(where: ContactSiteWhereInput): BatchPayload!
  createNote(data: NoteCreateInput!): Note!
  updateNote(data: NoteUpdateInput!, where: NoteWhereUniqueInput!): Note
  updateManyNotes(data: NoteUpdateManyMutationInput!, where: NoteWhereInput): BatchPayload!
  upsertNote(where: NoteWhereUniqueInput!, create: NoteCreateInput!, update: NoteUpdateInput!): Note!
  deleteNote(where: NoteWhereUniqueInput!): Note
  deleteManyNotes(where: NoteWhereInput): BatchPayload!
  createPermission(data: PermissionCreateInput!): Permission!
  updatePermission(data: PermissionUpdateInput!, where: PermissionWhereUniqueInput!): Permission
  updateManyPermissions(data: PermissionUpdateManyMutationInput!, where: PermissionWhereInput): BatchPayload!
  upsertPermission(where: PermissionWhereUniqueInput!, create: PermissionCreateInput!, update: PermissionUpdateInput!): Permission!
  deletePermission(where: PermissionWhereUniqueInput!): Permission
  deleteManyPermissions(where: PermissionWhereInput): BatchPayload!
  createPerson(data: PersonCreateInput!): Person!
  updatePerson(data: PersonUpdateInput!, where: PersonWhereUniqueInput!): Person
  updateManyPersons(data: PersonUpdateManyMutationInput!, where: PersonWhereInput): BatchPayload!
  upsertPerson(where: PersonWhereUniqueInput!, create: PersonCreateInput!, update: PersonUpdateInput!): Person!
  deletePerson(where: PersonWhereUniqueInput!): Person
  deleteManyPersons(where: PersonWhereInput): BatchPayload!
  createPersonStatus(data: PersonStatusCreateInput!): PersonStatus!
  updatePersonStatus(data: PersonStatusUpdateInput!, where: PersonStatusWhereUniqueInput!): PersonStatus
  updateManyPersonStatuses(data: PersonStatusUpdateManyMutationInput!, where: PersonStatusWhereInput): BatchPayload!
  upsertPersonStatus(where: PersonStatusWhereUniqueInput!, create: PersonStatusCreateInput!, update: PersonStatusUpdateInput!): PersonStatus!
  deletePersonStatus(where: PersonStatusWhereUniqueInput!): PersonStatus
  deleteManyPersonStatuses(where: PersonStatusWhereInput): BatchPayload!
  createTeam(data: TeamCreateInput!): Team!
  updateTeam(data: TeamUpdateInput!, where: TeamWhereUniqueInput!): Team
  updateManyTeams(data: TeamUpdateManyMutationInput!, where: TeamWhereInput): BatchPayload!
  upsertTeam(where: TeamWhereUniqueInput!, create: TeamCreateInput!, update: TeamUpdateInput!): Team!
  deleteTeam(where: TeamWhereUniqueInput!): Team
  deleteManyTeams(where: TeamWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createUserRole(data: UserRoleCreateInput!): UserRole!
  updateUserRole(data: UserRoleUpdateInput!, where: UserRoleWhereUniqueInput!): UserRole
  updateManyUserRoles(data: UserRoleUpdateManyMutationInput!, where: UserRoleWhereInput): BatchPayload!
  upsertUserRole(where: UserRoleWhereUniqueInput!, create: UserRoleCreateInput!, update: UserRoleUpdateInput!): UserRole!
  deleteUserRole(where: UserRoleWhereUniqueInput!): UserRole
  deleteManyUserRoles(where: UserRoleWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Note {
  id: ID!
  date: DateTime!
  user: User!
  message: String!
}

type NoteConnection {
  pageInfo: PageInfo!
  edges: [NoteEdge]!
  aggregate: AggregateNote!
}

input NoteCreateInput {
  date: DateTime!
  user: UserCreateOneInput!
  message: String!
}

input NoteCreateManyInput {
  create: [NoteCreateInput!]
  connect: [NoteWhereUniqueInput!]
}

type NoteEdge {
  node: Note!
  cursor: String!
}

enum NoteOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NotePreviousValues {
  id: ID!
  date: DateTime!
  message: String!
}

input NoteScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [NoteScalarWhereInput!]
  OR: [NoteScalarWhereInput!]
  NOT: [NoteScalarWhereInput!]
}

type NoteSubscriptionPayload {
  mutation: MutationType!
  node: Note
  updatedFields: [String!]
  previousValues: NotePreviousValues
}

input NoteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NoteWhereInput
  AND: [NoteSubscriptionWhereInput!]
  OR: [NoteSubscriptionWhereInput!]
  NOT: [NoteSubscriptionWhereInput!]
}

input NoteUpdateDataInput {
  date: DateTime
  user: UserUpdateOneRequiredInput
  message: String
}

input NoteUpdateInput {
  date: DateTime
  user: UserUpdateOneRequiredInput
  message: String
}

input NoteUpdateManyDataInput {
  date: DateTime
  message: String
}

input NoteUpdateManyInput {
  create: [NoteCreateInput!]
  update: [NoteUpdateWithWhereUniqueNestedInput!]
  upsert: [NoteUpsertWithWhereUniqueNestedInput!]
  delete: [NoteWhereUniqueInput!]
  connect: [NoteWhereUniqueInput!]
  set: [NoteWhereUniqueInput!]
  disconnect: [NoteWhereUniqueInput!]
  deleteMany: [NoteScalarWhereInput!]
  updateMany: [NoteUpdateManyWithWhereNestedInput!]
}

input NoteUpdateManyMutationInput {
  date: DateTime
  message: String
}

input NoteUpdateManyWithWhereNestedInput {
  where: NoteScalarWhereInput!
  data: NoteUpdateManyDataInput!
}

input NoteUpdateWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput!
  data: NoteUpdateDataInput!
}

input NoteUpsertWithWhereUniqueNestedInput {
  where: NoteWhereUniqueInput!
  update: NoteUpdateDataInput!
  create: NoteCreateInput!
}

input NoteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  user: UserWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  AND: [NoteWhereInput!]
  OR: [NoteWhereInput!]
  NOT: [NoteWhereInput!]
}

input NoteWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Permission {
  id: ID!
  title: String!
}

type PermissionConnection {
  pageInfo: PageInfo!
  edges: [PermissionEdge]!
  aggregate: AggregatePermission!
}

input PermissionCreateInput {
  title: String!
}

input PermissionCreateManyInput {
  create: [PermissionCreateInput!]
  connect: [PermissionWhereUniqueInput!]
}

type PermissionEdge {
  node: Permission!
  cursor: String!
}

enum PermissionOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PermissionPreviousValues {
  id: ID!
  title: String!
}

input PermissionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [PermissionScalarWhereInput!]
  OR: [PermissionScalarWhereInput!]
  NOT: [PermissionScalarWhereInput!]
}

type PermissionSubscriptionPayload {
  mutation: MutationType!
  node: Permission
  updatedFields: [String!]
  previousValues: PermissionPreviousValues
}

input PermissionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PermissionWhereInput
  AND: [PermissionSubscriptionWhereInput!]
  OR: [PermissionSubscriptionWhereInput!]
  NOT: [PermissionSubscriptionWhereInput!]
}

input PermissionUpdateDataInput {
  title: String
}

input PermissionUpdateInput {
  title: String
}

input PermissionUpdateManyDataInput {
  title: String
}

input PermissionUpdateManyInput {
  create: [PermissionCreateInput!]
  update: [PermissionUpdateWithWhereUniqueNestedInput!]
  upsert: [PermissionUpsertWithWhereUniqueNestedInput!]
  delete: [PermissionWhereUniqueInput!]
  connect: [PermissionWhereUniqueInput!]
  set: [PermissionWhereUniqueInput!]
  disconnect: [PermissionWhereUniqueInput!]
  deleteMany: [PermissionScalarWhereInput!]
  updateMany: [PermissionUpdateManyWithWhereNestedInput!]
}

input PermissionUpdateManyMutationInput {
  title: String
}

input PermissionUpdateManyWithWhereNestedInput {
  where: PermissionScalarWhereInput!
  data: PermissionUpdateManyDataInput!
}

input PermissionUpdateWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput!
  data: PermissionUpdateDataInput!
}

input PermissionUpsertWithWhereUniqueNestedInput {
  where: PermissionWhereUniqueInput!
  update: PermissionUpdateDataInput!
  create: PermissionCreateInput!
}

input PermissionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [PermissionWhereInput!]
  OR: [PermissionWhereInput!]
  NOT: [PermissionWhereInput!]
}

input PermissionWhereUniqueInput {
  id: ID
}

type Person {
  id: ID!
  name: String!
  name_search: String
  email: String
  password: String
  telephone: String
  cellphone: String
  status: PersonStatus!
  address: String
  sex: Sex!
  religion: String
  age: Int
  assignee: User
  contactSite: ContactSite!
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note!]
  websiteUser: Boolean!
  maritalStatus: MaritalStatus
  invitation: Boolean!
  letter: Boolean!
  handbill: Boolean!
  guestTag: Boolean!
  transport: Boolean!
  openingNight: Boolean!
  dob: DateTime
  team: Team
  teamCode: String
  teamCode_search: String
  lesson1: Boolean!
  lesson2: Boolean!
  lesson3: Boolean!
  lesson4: Boolean!
  lesson5: Boolean!
  lesson6: Boolean!
  lesson7: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
  addedBy: User
}

type PersonConnection {
  pageInfo: PageInfo!
  edges: [PersonEdge]!
  aggregate: AggregatePerson!
}

input PersonCreateInput {
  name: String!
  name_search: String
  email: String
  password: String
  telephone: String
  cellphone: String
  status: PersonStatusCreateOneInput!
  address: String
  sex: Sex!
  religion: String
  age: Int
  assignee: UserCreateOneInput
  contactSite: ContactSiteCreateOneInput!
  notes: NoteCreateManyInput
  websiteUser: Boolean
  maritalStatus: MaritalStatus
  invitation: Boolean
  letter: Boolean
  handbill: Boolean
  guestTag: Boolean
  transport: Boolean
  openingNight: Boolean
  dob: DateTime
  team: TeamCreateOneInput
  teamCode: String
  teamCode_search: String
  lesson1: Boolean
  lesson2: Boolean
  lesson3: Boolean
  lesson4: Boolean
  lesson5: Boolean
  lesson6: Boolean
  lesson7: Boolean
  addedBy: UserCreateOneInput
}

input PersonCreateOneInput {
  create: PersonCreateInput
  connect: PersonWhereUniqueInput
}

type PersonEdge {
  node: Person!
  cursor: String!
}

enum PersonOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  name_search_ASC
  name_search_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  telephone_ASC
  telephone_DESC
  cellphone_ASC
  cellphone_DESC
  address_ASC
  address_DESC
  sex_ASC
  sex_DESC
  religion_ASC
  religion_DESC
  age_ASC
  age_DESC
  websiteUser_ASC
  websiteUser_DESC
  maritalStatus_ASC
  maritalStatus_DESC
  invitation_ASC
  invitation_DESC
  letter_ASC
  letter_DESC
  handbill_ASC
  handbill_DESC
  guestTag_ASC
  guestTag_DESC
  transport_ASC
  transport_DESC
  openingNight_ASC
  openingNight_DESC
  dob_ASC
  dob_DESC
  teamCode_ASC
  teamCode_DESC
  teamCode_search_ASC
  teamCode_search_DESC
  lesson1_ASC
  lesson1_DESC
  lesson2_ASC
  lesson2_DESC
  lesson3_ASC
  lesson3_DESC
  lesson4_ASC
  lesson4_DESC
  lesson5_ASC
  lesson5_DESC
  lesson6_ASC
  lesson6_DESC
  lesson7_ASC
  lesson7_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PersonPreviousValues {
  id: ID!
  name: String!
  name_search: String
  email: String
  password: String
  telephone: String
  cellphone: String
  address: String
  sex: Sex!
  religion: String
  age: Int
  websiteUser: Boolean!
  maritalStatus: MaritalStatus
  invitation: Boolean!
  letter: Boolean!
  handbill: Boolean!
  guestTag: Boolean!
  transport: Boolean!
  openingNight: Boolean!
  dob: DateTime
  teamCode: String
  teamCode_search: String
  lesson1: Boolean!
  lesson2: Boolean!
  lesson3: Boolean!
  lesson4: Boolean!
  lesson5: Boolean!
  lesson6: Boolean!
  lesson7: Boolean!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PersonStatus {
  title: String!
  description: String
}

type PersonStatusConnection {
  pageInfo: PageInfo!
  edges: [PersonStatusEdge]!
  aggregate: AggregatePersonStatus!
}

input PersonStatusCreateInput {
  title: String!
  description: String
}

input PersonStatusCreateOneInput {
  create: PersonStatusCreateInput
  connect: PersonStatusWhereUniqueInput
}

type PersonStatusEdge {
  node: PersonStatus!
  cursor: String!
}

enum PersonStatusOrderByInput {
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PersonStatusPreviousValues {
  title: String!
  description: String
}

type PersonStatusSubscriptionPayload {
  mutation: MutationType!
  node: PersonStatus
  updatedFields: [String!]
  previousValues: PersonStatusPreviousValues
}

input PersonStatusSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PersonStatusWhereInput
  AND: [PersonStatusSubscriptionWhereInput!]
  OR: [PersonStatusSubscriptionWhereInput!]
  NOT: [PersonStatusSubscriptionWhereInput!]
}

input PersonStatusUpdateDataInput {
  title: String
  description: String
}

input PersonStatusUpdateInput {
  title: String
  description: String
}

input PersonStatusUpdateManyMutationInput {
  title: String
  description: String
}

input PersonStatusUpdateOneRequiredInput {
  create: PersonStatusCreateInput
  update: PersonStatusUpdateDataInput
  upsert: PersonStatusUpsertNestedInput
  connect: PersonStatusWhereUniqueInput
}

input PersonStatusUpsertNestedInput {
  update: PersonStatusUpdateDataInput!
  create: PersonStatusCreateInput!
}

input PersonStatusWhereInput {
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [PersonStatusWhereInput!]
  OR: [PersonStatusWhereInput!]
  NOT: [PersonStatusWhereInput!]
}

input PersonStatusWhereUniqueInput {
  title: String
}

type PersonSubscriptionPayload {
  mutation: MutationType!
  node: Person
  updatedFields: [String!]
  previousValues: PersonPreviousValues
}

input PersonSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PersonWhereInput
  AND: [PersonSubscriptionWhereInput!]
  OR: [PersonSubscriptionWhereInput!]
  NOT: [PersonSubscriptionWhereInput!]
}

input PersonUpdateInput {
  name: String
  name_search: String
  email: String
  password: String
  telephone: String
  cellphone: String
  status: PersonStatusUpdateOneRequiredInput
  address: String
  sex: Sex
  religion: String
  age: Int
  assignee: UserUpdateOneInput
  contactSite: ContactSiteUpdateOneRequiredInput
  notes: NoteUpdateManyInput
  websiteUser: Boolean
  maritalStatus: MaritalStatus
  invitation: Boolean
  letter: Boolean
  handbill: Boolean
  guestTag: Boolean
  transport: Boolean
  openingNight: Boolean
  dob: DateTime
  team: TeamUpdateOneInput
  teamCode: String
  teamCode_search: String
  lesson1: Boolean
  lesson2: Boolean
  lesson3: Boolean
  lesson4: Boolean
  lesson5: Boolean
  lesson6: Boolean
  lesson7: Boolean
  addedBy: UserUpdateOneInput
}

input PersonUpdateManyMutationInput {
  name: String
  name_search: String
  email: String
  password: String
  telephone: String
  cellphone: String
  address: String
  sex: Sex
  religion: String
  age: Int
  websiteUser: Boolean
  maritalStatus: MaritalStatus
  invitation: Boolean
  letter: Boolean
  handbill: Boolean
  guestTag: Boolean
  transport: Boolean
  openingNight: Boolean
  dob: DateTime
  teamCode: String
  teamCode_search: String
  lesson1: Boolean
  lesson2: Boolean
  lesson3: Boolean
  lesson4: Boolean
  lesson5: Boolean
  lesson6: Boolean
  lesson7: Boolean
}

input PersonWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  name_search: String
  name_search_not: String
  name_search_in: [String!]
  name_search_not_in: [String!]
  name_search_lt: String
  name_search_lte: String
  name_search_gt: String
  name_search_gte: String
  name_search_contains: String
  name_search_not_contains: String
  name_search_starts_with: String
  name_search_not_starts_with: String
  name_search_ends_with: String
  name_search_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  telephone: String
  telephone_not: String
  telephone_in: [String!]
  telephone_not_in: [String!]
  telephone_lt: String
  telephone_lte: String
  telephone_gt: String
  telephone_gte: String
  telephone_contains: String
  telephone_not_contains: String
  telephone_starts_with: String
  telephone_not_starts_with: String
  telephone_ends_with: String
  telephone_not_ends_with: String
  cellphone: String
  cellphone_not: String
  cellphone_in: [String!]
  cellphone_not_in: [String!]
  cellphone_lt: String
  cellphone_lte: String
  cellphone_gt: String
  cellphone_gte: String
  cellphone_contains: String
  cellphone_not_contains: String
  cellphone_starts_with: String
  cellphone_not_starts_with: String
  cellphone_ends_with: String
  cellphone_not_ends_with: String
  status: PersonStatusWhereInput
  address: String
  address_not: String
  address_in: [String!]
  address_not_in: [String!]
  address_lt: String
  address_lte: String
  address_gt: String
  address_gte: String
  address_contains: String
  address_not_contains: String
  address_starts_with: String
  address_not_starts_with: String
  address_ends_with: String
  address_not_ends_with: String
  sex: Sex
  sex_not: Sex
  sex_in: [Sex!]
  sex_not_in: [Sex!]
  religion: String
  religion_not: String
  religion_in: [String!]
  religion_not_in: [String!]
  religion_lt: String
  religion_lte: String
  religion_gt: String
  religion_gte: String
  religion_contains: String
  religion_not_contains: String
  religion_starts_with: String
  religion_not_starts_with: String
  religion_ends_with: String
  religion_not_ends_with: String
  age: Int
  age_not: Int
  age_in: [Int!]
  age_not_in: [Int!]
  age_lt: Int
  age_lte: Int
  age_gt: Int
  age_gte: Int
  assignee: UserWhereInput
  contactSite: ContactSiteWhereInput
  notes_every: NoteWhereInput
  notes_some: NoteWhereInput
  notes_none: NoteWhereInput
  websiteUser: Boolean
  websiteUser_not: Boolean
  maritalStatus: MaritalStatus
  maritalStatus_not: MaritalStatus
  maritalStatus_in: [MaritalStatus!]
  maritalStatus_not_in: [MaritalStatus!]
  invitation: Boolean
  invitation_not: Boolean
  letter: Boolean
  letter_not: Boolean
  handbill: Boolean
  handbill_not: Boolean
  guestTag: Boolean
  guestTag_not: Boolean
  transport: Boolean
  transport_not: Boolean
  openingNight: Boolean
  openingNight_not: Boolean
  dob: DateTime
  dob_not: DateTime
  dob_in: [DateTime!]
  dob_not_in: [DateTime!]
  dob_lt: DateTime
  dob_lte: DateTime
  dob_gt: DateTime
  dob_gte: DateTime
  team: TeamWhereInput
  teamCode: String
  teamCode_not: String
  teamCode_in: [String!]
  teamCode_not_in: [String!]
  teamCode_lt: String
  teamCode_lte: String
  teamCode_gt: String
  teamCode_gte: String
  teamCode_contains: String
  teamCode_not_contains: String
  teamCode_starts_with: String
  teamCode_not_starts_with: String
  teamCode_ends_with: String
  teamCode_not_ends_with: String
  teamCode_search: String
  teamCode_search_not: String
  teamCode_search_in: [String!]
  teamCode_search_not_in: [String!]
  teamCode_search_lt: String
  teamCode_search_lte: String
  teamCode_search_gt: String
  teamCode_search_gte: String
  teamCode_search_contains: String
  teamCode_search_not_contains: String
  teamCode_search_starts_with: String
  teamCode_search_not_starts_with: String
  teamCode_search_ends_with: String
  teamCode_search_not_ends_with: String
  lesson1: Boolean
  lesson1_not: Boolean
  lesson2: Boolean
  lesson2_not: Boolean
  lesson3: Boolean
  lesson3_not: Boolean
  lesson4: Boolean
  lesson4_not: Boolean
  lesson5: Boolean
  lesson5_not: Boolean
  lesson6: Boolean
  lesson6_not: Boolean
  lesson7: Boolean
  lesson7_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  addedBy: UserWhereInput
  AND: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
}

input PersonWhereUniqueInput {
  id: ID
  teamCode: String
  teamCode_search: String
}

type Query {
  attendances(where: AttendanceWhereInput, orderBy: AttendanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Attendance]!
  attendancesConnection(where: AttendanceWhereInput, orderBy: AttendanceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AttendanceConnection!
  contactSite(where: ContactSiteWhereUniqueInput!): ContactSite
  contactSites(where: ContactSiteWhereInput, orderBy: ContactSiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContactSite]!
  contactSitesConnection(where: ContactSiteWhereInput, orderBy: ContactSiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ContactSiteConnection!
  note(where: NoteWhereUniqueInput!): Note
  notes(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Note]!
  notesConnection(where: NoteWhereInput, orderBy: NoteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NoteConnection!
  permission(where: PermissionWhereUniqueInput!): Permission
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission]!
  permissionsConnection(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PermissionConnection!
  person(where: PersonWhereUniqueInput!): Person
  persons(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Person]!
  personsConnection(where: PersonWhereInput, orderBy: PersonOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonConnection!
  personStatus(where: PersonStatusWhereUniqueInput!): PersonStatus
  personStatuses(where: PersonStatusWhereInput, orderBy: PersonStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PersonStatus]!
  personStatusesConnection(where: PersonStatusWhereInput, orderBy: PersonStatusOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PersonStatusConnection!
  team(where: TeamWhereUniqueInput!): Team
  teams(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Team]!
  teamsConnection(where: TeamWhereInput, orderBy: TeamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TeamConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  userRole(where: UserRoleWhereUniqueInput!): UserRole
  userRoles(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [UserRole]!
  userRolesConnection(where: UserRoleWhereInput, orderBy: UserRoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserRoleConnection!
  node(id: ID!): Node
}

enum Sex {
  M
  F
}

type Subscription {
  attendance(where: AttendanceSubscriptionWhereInput): AttendanceSubscriptionPayload
  contactSite(where: ContactSiteSubscriptionWhereInput): ContactSiteSubscriptionPayload
  note(where: NoteSubscriptionWhereInput): NoteSubscriptionPayload
  permission(where: PermissionSubscriptionWhereInput): PermissionSubscriptionPayload
  person(where: PersonSubscriptionWhereInput): PersonSubscriptionPayload
  personStatus(where: PersonStatusSubscriptionWhereInput): PersonStatusSubscriptionPayload
  team(where: TeamSubscriptionWhereInput): TeamSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  userRole(where: UserRoleSubscriptionWhereInput): UserRoleSubscriptionPayload
}

type Team {
  id: ID!
  name: String!
  name_search: String
  contactSite: ContactSite!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamConnection {
  pageInfo: PageInfo!
  edges: [TeamEdge]!
  aggregate: AggregateTeam!
}

input TeamCreateInput {
  name: String!
  name_search: String
  contactSite: ContactSiteCreateOneInput!
}

input TeamCreateOneInput {
  create: TeamCreateInput
  connect: TeamWhereUniqueInput
}

type TeamEdge {
  node: Team!
  cursor: String!
}

enum TeamOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  name_search_ASC
  name_search_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TeamPreviousValues {
  id: ID!
  name: String!
  name_search: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TeamSubscriptionPayload {
  mutation: MutationType!
  node: Team
  updatedFields: [String!]
  previousValues: TeamPreviousValues
}

input TeamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TeamWhereInput
  AND: [TeamSubscriptionWhereInput!]
  OR: [TeamSubscriptionWhereInput!]
  NOT: [TeamSubscriptionWhereInput!]
}

input TeamUpdateDataInput {
  name: String
  name_search: String
  contactSite: ContactSiteUpdateOneRequiredInput
}

input TeamUpdateInput {
  name: String
  name_search: String
  contactSite: ContactSiteUpdateOneRequiredInput
}

input TeamUpdateManyMutationInput {
  name: String
  name_search: String
}

input TeamUpdateOneInput {
  create: TeamCreateInput
  update: TeamUpdateDataInput
  upsert: TeamUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: TeamWhereUniqueInput
}

input TeamUpsertNestedInput {
  update: TeamUpdateDataInput!
  create: TeamCreateInput!
}

input TeamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  name_search: String
  name_search_not: String
  name_search_in: [String!]
  name_search_not_in: [String!]
  name_search_lt: String
  name_search_lte: String
  name_search_gt: String
  name_search_gte: String
  name_search_contains: String
  name_search_not_contains: String
  name_search_starts_with: String
  name_search_not_starts_with: String
  name_search_ends_with: String
  name_search_not_ends_with: String
  contactSite: ContactSiteWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TeamWhereInput!]
  OR: [TeamWhereInput!]
  NOT: [TeamWhereInput!]
}

input TeamWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  role: UserRole!
  contactSites(where: ContactSiteWhereInput, orderBy: ContactSiteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ContactSite!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  name: String!
  email: String!
  password: String!
  role: UserRoleCreateOneInput!
  contactSites: ContactSiteCreateManyInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
}

type UserRole {
  title: String!
  permissions(where: PermissionWhereInput, orderBy: PermissionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Permission!]
}

type UserRoleConnection {
  pageInfo: PageInfo!
  edges: [UserRoleEdge]!
  aggregate: AggregateUserRole!
}

input UserRoleCreateInput {
  title: String!
  permissions: PermissionCreateManyInput
}

input UserRoleCreateOneInput {
  create: UserRoleCreateInput
  connect: UserRoleWhereUniqueInput
}

type UserRoleEdge {
  node: UserRole!
  cursor: String!
}

enum UserRoleOrderByInput {
  title_ASC
  title_DESC
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserRolePreviousValues {
  title: String!
}

type UserRoleSubscriptionPayload {
  mutation: MutationType!
  node: UserRole
  updatedFields: [String!]
  previousValues: UserRolePreviousValues
}

input UserRoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserRoleWhereInput
  AND: [UserRoleSubscriptionWhereInput!]
  OR: [UserRoleSubscriptionWhereInput!]
  NOT: [UserRoleSubscriptionWhereInput!]
}

input UserRoleUpdateDataInput {
  title: String
  permissions: PermissionUpdateManyInput
}

input UserRoleUpdateInput {
  title: String
  permissions: PermissionUpdateManyInput
}

input UserRoleUpdateManyMutationInput {
  title: String
}

input UserRoleUpdateOneRequiredInput {
  create: UserRoleCreateInput
  update: UserRoleUpdateDataInput
  upsert: UserRoleUpsertNestedInput
  connect: UserRoleWhereUniqueInput
}

input UserRoleUpsertNestedInput {
  update: UserRoleUpdateDataInput!
  create: UserRoleCreateInput!
}

input UserRoleWhereInput {
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  permissions_every: PermissionWhereInput
  permissions_some: PermissionWhereInput
  permissions_none: PermissionWhereInput
  AND: [UserRoleWhereInput!]
  OR: [UserRoleWhereInput!]
  NOT: [UserRoleWhereInput!]
}

input UserRoleWhereUniqueInput {
  title: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
  role: UserRoleUpdateOneRequiredInput
  contactSites: ContactSiteUpdateManyInput
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  role: UserRoleUpdateOneRequiredInput
  contactSites: ContactSiteUpdateManyInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  role: UserRoleWhereInput
  contactSites_every: ContactSiteWhereInput
  contactSites_some: ContactSiteWhereInput
  contactSites_none: ContactSiteWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    